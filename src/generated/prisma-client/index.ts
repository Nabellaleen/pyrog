// Code generated by Prisma (prisma@1.27.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  database: (where?: DatabaseWhereInput) => Promise<boolean>;
  inputColumn: (where?: InputColumnWhereInput) => Promise<boolean>;
  join: (where?: JoinWhereInput) => Promise<boolean>;
  resource: (where?: ResourceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  attributes: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Attribute>;
  attributesConnection: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttributeConnectionPromise;
  database: (where: DatabaseWhereUniqueInput) => DatabasePromise;
  databases: (
    args?: {
      where?: DatabaseWhereInput;
      orderBy?: DatabaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Database>;
  databasesConnection: (
    args?: {
      where?: DatabaseWhereInput;
      orderBy?: DatabaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DatabaseConnectionPromise;
  inputColumn: (where: InputColumnWhereUniqueInput) => InputColumnPromise;
  inputColumns: (
    args?: {
      where?: InputColumnWhereInput;
      orderBy?: InputColumnOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<InputColumn>;
  inputColumnsConnection: (
    args?: {
      where?: InputColumnWhereInput;
      orderBy?: InputColumnOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InputColumnConnectionPromise;
  join: (where: JoinWhereUniqueInput) => JoinPromise;
  joins: (
    args?: {
      where?: JoinWhereInput;
      orderBy?: JoinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Join>;
  joinsConnection: (
    args?: {
      where?: JoinWhereInput;
      orderBy?: JoinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => JoinConnectionPromise;
  resource: (where: ResourceWhereUniqueInput) => ResourcePromise;
  resources: (
    args?: {
      where?: ResourceWhereInput;
      orderBy?: ResourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Resource>;
  resourcesConnection: (
    args?: {
      where?: ResourceWhereInput;
      orderBy?: ResourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ResourceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (
    args: { data: AttributeUpdateInput; where: AttributeWhereUniqueInput }
  ) => AttributePromise;
  updateManyAttributes: (
    args: {
      data: AttributeUpdateManyMutationInput;
      where?: AttributeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAttribute: (
    args: {
      where: AttributeWhereUniqueInput;
      create: AttributeCreateInput;
      update: AttributeUpdateInput;
    }
  ) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createDatabase: (data: DatabaseCreateInput) => DatabasePromise;
  updateDatabase: (
    args: { data: DatabaseUpdateInput; where: DatabaseWhereUniqueInput }
  ) => DatabasePromise;
  updateManyDatabases: (
    args: { data: DatabaseUpdateManyMutationInput; where?: DatabaseWhereInput }
  ) => BatchPayloadPromise;
  upsertDatabase: (
    args: {
      where: DatabaseWhereUniqueInput;
      create: DatabaseCreateInput;
      update: DatabaseUpdateInput;
    }
  ) => DatabasePromise;
  deleteDatabase: (where: DatabaseWhereUniqueInput) => DatabasePromise;
  deleteManyDatabases: (where?: DatabaseWhereInput) => BatchPayloadPromise;
  createInputColumn: (data: InputColumnCreateInput) => InputColumnPromise;
  updateInputColumn: (
    args: { data: InputColumnUpdateInput; where: InputColumnWhereUniqueInput }
  ) => InputColumnPromise;
  updateManyInputColumns: (
    args: {
      data: InputColumnUpdateManyMutationInput;
      where?: InputColumnWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertInputColumn: (
    args: {
      where: InputColumnWhereUniqueInput;
      create: InputColumnCreateInput;
      update: InputColumnUpdateInput;
    }
  ) => InputColumnPromise;
  deleteInputColumn: (where: InputColumnWhereUniqueInput) => InputColumnPromise;
  deleteManyInputColumns: (
    where?: InputColumnWhereInput
  ) => BatchPayloadPromise;
  createJoin: (data: JoinCreateInput) => JoinPromise;
  updateJoin: (
    args: { data: JoinUpdateInput; where: JoinWhereUniqueInput }
  ) => JoinPromise;
  updateManyJoins: (
    args: { data: JoinUpdateManyMutationInput; where?: JoinWhereInput }
  ) => BatchPayloadPromise;
  upsertJoin: (
    args: {
      where: JoinWhereUniqueInput;
      create: JoinCreateInput;
      update: JoinUpdateInput;
    }
  ) => JoinPromise;
  deleteJoin: (where: JoinWhereUniqueInput) => JoinPromise;
  deleteManyJoins: (where?: JoinWhereInput) => BatchPayloadPromise;
  createResource: (data: ResourceCreateInput) => ResourcePromise;
  updateResource: (
    args: { data: ResourceUpdateInput; where: ResourceWhereUniqueInput }
  ) => ResourcePromise;
  updateManyResources: (
    args: { data: ResourceUpdateManyMutationInput; where?: ResourceWhereInput }
  ) => BatchPayloadPromise;
  upsertResource: (
    args: {
      where: ResourceWhereUniqueInput;
      create: ResourceCreateInput;
      update: ResourceUpdateInput;
    }
  ) => ResourcePromise;
  deleteResource: (where: ResourceWhereUniqueInput) => ResourcePromise;
  deleteManyResources: (where?: ResourceWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  database: (
    where?: DatabaseSubscriptionWhereInput
  ) => DatabaseSubscriptionPayloadSubscription;
  inputColumn: (
    where?: InputColumnSubscriptionWhereInput
  ) => InputColumnSubscriptionPayloadSubscription;
  join: (
    where?: JoinSubscriptionWhereInput
  ) => JoinSubscriptionPayloadSubscription;
  resource: (
    where?: ResourceSubscriptionWhereInput
  ) => ResourceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "mergingScript_ASC"
  | "mergingScript_DESC"
  | "isProfile_ASC"
  | "isProfile_DESC"
  | "type_ASC"
  | "type_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "depth_ASC"
  | "depth_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "primaryKeyOwner_ASC"
  | "primaryKeyOwner_DESC"
  | "primaryKeyTable_ASC"
  | "primaryKeyTable_DESC"
  | "primaryKeyColumn_ASC"
  | "primaryKeyColumn_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InputColumnOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "table_ASC"
  | "table_DESC"
  | "column_ASC"
  | "column_DESC"
  | "script_ASC"
  | "script_DESC"
  | "staticValue_ASC"
  | "staticValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type JoinOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sourceOwner_ASC"
  | "sourceOwner_DESC"
  | "sourceTable_ASC"
  | "sourceTable_DESC"
  | "sourceColumn_ASC"
  | "sourceColumn_DESC"
  | "targetOwner_ASC"
  | "targetOwner_DESC"
  | "targetTable_ASC"
  | "targetTable_DESC"
  | "targetColumn_ASC"
  | "targetColumn_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DatabaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Role = "ADMIN" | "USER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  mergingScript?: String;
  mergingScript_not?: String;
  mergingScript_in?: String[] | String;
  mergingScript_not_in?: String[] | String;
  mergingScript_lt?: String;
  mergingScript_lte?: String;
  mergingScript_gt?: String;
  mergingScript_gte?: String;
  mergingScript_contains?: String;
  mergingScript_not_contains?: String;
  mergingScript_starts_with?: String;
  mergingScript_not_starts_with?: String;
  mergingScript_ends_with?: String;
  mergingScript_not_ends_with?: String;
  isProfile?: Boolean;
  isProfile_not?: Boolean;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  comment?: String;
  comment_not?: String;
  comment_in?: String[] | String;
  comment_not_in?: String[] | String;
  comment_lt?: String;
  comment_lte?: String;
  comment_gt?: String;
  comment_gte?: String;
  comment_contains?: String;
  comment_not_contains?: String;
  comment_starts_with?: String;
  comment_not_starts_with?: String;
  comment_ends_with?: String;
  comment_not_ends_with?: String;
  depth?: Int;
  depth_not?: Int;
  depth_in?: Int[] | Int;
  depth_not_in?: Int[] | Int;
  depth_lt?: Int;
  depth_lte?: Int;
  depth_gt?: Int;
  depth_gte?: Int;
  resource?: ResourceWhereInput;
  attributes_every?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  attribute?: AttributeWhereInput;
  inputColumns_every?: InputColumnWhereInput;
  inputColumns_some?: InputColumnWhereInput;
  inputColumns_none?: InputColumnWhereInput;
  AND?: AttributeWhereInput[] | AttributeWhereInput;
  OR?: AttributeWhereInput[] | AttributeWhereInput;
  NOT?: AttributeWhereInput[] | AttributeWhereInput;
}

export interface ResourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  primaryKeyOwner?: String;
  primaryKeyOwner_not?: String;
  primaryKeyOwner_in?: String[] | String;
  primaryKeyOwner_not_in?: String[] | String;
  primaryKeyOwner_lt?: String;
  primaryKeyOwner_lte?: String;
  primaryKeyOwner_gt?: String;
  primaryKeyOwner_gte?: String;
  primaryKeyOwner_contains?: String;
  primaryKeyOwner_not_contains?: String;
  primaryKeyOwner_starts_with?: String;
  primaryKeyOwner_not_starts_with?: String;
  primaryKeyOwner_ends_with?: String;
  primaryKeyOwner_not_ends_with?: String;
  primaryKeyTable?: String;
  primaryKeyTable_not?: String;
  primaryKeyTable_in?: String[] | String;
  primaryKeyTable_not_in?: String[] | String;
  primaryKeyTable_lt?: String;
  primaryKeyTable_lte?: String;
  primaryKeyTable_gt?: String;
  primaryKeyTable_gte?: String;
  primaryKeyTable_contains?: String;
  primaryKeyTable_not_contains?: String;
  primaryKeyTable_starts_with?: String;
  primaryKeyTable_not_starts_with?: String;
  primaryKeyTable_ends_with?: String;
  primaryKeyTable_not_ends_with?: String;
  primaryKeyColumn?: String;
  primaryKeyColumn_not?: String;
  primaryKeyColumn_in?: String[] | String;
  primaryKeyColumn_not_in?: String[] | String;
  primaryKeyColumn_lt?: String;
  primaryKeyColumn_lte?: String;
  primaryKeyColumn_gt?: String;
  primaryKeyColumn_gte?: String;
  primaryKeyColumn_contains?: String;
  primaryKeyColumn_not_contains?: String;
  primaryKeyColumn_starts_with?: String;
  primaryKeyColumn_not_starts_with?: String;
  primaryKeyColumn_ends_with?: String;
  primaryKeyColumn_not_ends_with?: String;
  attributes_every?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  database?: DatabaseWhereInput;
  AND?: ResourceWhereInput[] | ResourceWhereInput;
  OR?: ResourceWhereInput[] | ResourceWhereInput;
  NOT?: ResourceWhereInput[] | ResourceWhereInput;
}

export interface DatabaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  resources_every?: ResourceWhereInput;
  resources_some?: ResourceWhereInput;
  resources_none?: ResourceWhereInput;
  AND?: DatabaseWhereInput[] | DatabaseWhereInput;
  OR?: DatabaseWhereInput[] | DatabaseWhereInput;
  NOT?: DatabaseWhereInput[] | DatabaseWhereInput;
}

export interface InputColumnWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: String;
  owner_not?: String;
  owner_in?: String[] | String;
  owner_not_in?: String[] | String;
  owner_lt?: String;
  owner_lte?: String;
  owner_gt?: String;
  owner_gte?: String;
  owner_contains?: String;
  owner_not_contains?: String;
  owner_starts_with?: String;
  owner_not_starts_with?: String;
  owner_ends_with?: String;
  owner_not_ends_with?: String;
  table?: String;
  table_not?: String;
  table_in?: String[] | String;
  table_not_in?: String[] | String;
  table_lt?: String;
  table_lte?: String;
  table_gt?: String;
  table_gte?: String;
  table_contains?: String;
  table_not_contains?: String;
  table_starts_with?: String;
  table_not_starts_with?: String;
  table_ends_with?: String;
  table_not_ends_with?: String;
  column?: String;
  column_not?: String;
  column_in?: String[] | String;
  column_not_in?: String[] | String;
  column_lt?: String;
  column_lte?: String;
  column_gt?: String;
  column_gte?: String;
  column_contains?: String;
  column_not_contains?: String;
  column_starts_with?: String;
  column_not_starts_with?: String;
  column_ends_with?: String;
  column_not_ends_with?: String;
  script?: String;
  script_not?: String;
  script_in?: String[] | String;
  script_not_in?: String[] | String;
  script_lt?: String;
  script_lte?: String;
  script_gt?: String;
  script_gte?: String;
  script_contains?: String;
  script_not_contains?: String;
  script_starts_with?: String;
  script_not_starts_with?: String;
  script_ends_with?: String;
  script_not_ends_with?: String;
  staticValue?: String;
  staticValue_not?: String;
  staticValue_in?: String[] | String;
  staticValue_not_in?: String[] | String;
  staticValue_lt?: String;
  staticValue_lte?: String;
  staticValue_gt?: String;
  staticValue_gte?: String;
  staticValue_contains?: String;
  staticValue_not_contains?: String;
  staticValue_starts_with?: String;
  staticValue_not_starts_with?: String;
  staticValue_ends_with?: String;
  staticValue_not_ends_with?: String;
  joins_every?: JoinWhereInput;
  joins_some?: JoinWhereInput;
  joins_none?: JoinWhereInput;
  attribute?: AttributeWhereInput;
  AND?: InputColumnWhereInput[] | InputColumnWhereInput;
  OR?: InputColumnWhereInput[] | InputColumnWhereInput;
  NOT?: InputColumnWhereInput[] | InputColumnWhereInput;
}

export interface JoinWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  sourceOwner?: String;
  sourceOwner_not?: String;
  sourceOwner_in?: String[] | String;
  sourceOwner_not_in?: String[] | String;
  sourceOwner_lt?: String;
  sourceOwner_lte?: String;
  sourceOwner_gt?: String;
  sourceOwner_gte?: String;
  sourceOwner_contains?: String;
  sourceOwner_not_contains?: String;
  sourceOwner_starts_with?: String;
  sourceOwner_not_starts_with?: String;
  sourceOwner_ends_with?: String;
  sourceOwner_not_ends_with?: String;
  sourceTable?: String;
  sourceTable_not?: String;
  sourceTable_in?: String[] | String;
  sourceTable_not_in?: String[] | String;
  sourceTable_lt?: String;
  sourceTable_lte?: String;
  sourceTable_gt?: String;
  sourceTable_gte?: String;
  sourceTable_contains?: String;
  sourceTable_not_contains?: String;
  sourceTable_starts_with?: String;
  sourceTable_not_starts_with?: String;
  sourceTable_ends_with?: String;
  sourceTable_not_ends_with?: String;
  sourceColumn?: String;
  sourceColumn_not?: String;
  sourceColumn_in?: String[] | String;
  sourceColumn_not_in?: String[] | String;
  sourceColumn_lt?: String;
  sourceColumn_lte?: String;
  sourceColumn_gt?: String;
  sourceColumn_gte?: String;
  sourceColumn_contains?: String;
  sourceColumn_not_contains?: String;
  sourceColumn_starts_with?: String;
  sourceColumn_not_starts_with?: String;
  sourceColumn_ends_with?: String;
  sourceColumn_not_ends_with?: String;
  targetOwner?: String;
  targetOwner_not?: String;
  targetOwner_in?: String[] | String;
  targetOwner_not_in?: String[] | String;
  targetOwner_lt?: String;
  targetOwner_lte?: String;
  targetOwner_gt?: String;
  targetOwner_gte?: String;
  targetOwner_contains?: String;
  targetOwner_not_contains?: String;
  targetOwner_starts_with?: String;
  targetOwner_not_starts_with?: String;
  targetOwner_ends_with?: String;
  targetOwner_not_ends_with?: String;
  targetTable?: String;
  targetTable_not?: String;
  targetTable_in?: String[] | String;
  targetTable_not_in?: String[] | String;
  targetTable_lt?: String;
  targetTable_lte?: String;
  targetTable_gt?: String;
  targetTable_gte?: String;
  targetTable_contains?: String;
  targetTable_not_contains?: String;
  targetTable_starts_with?: String;
  targetTable_not_starts_with?: String;
  targetTable_ends_with?: String;
  targetTable_not_ends_with?: String;
  targetColumn?: String;
  targetColumn_not?: String;
  targetColumn_in?: String[] | String;
  targetColumn_not_in?: String[] | String;
  targetColumn_lt?: String;
  targetColumn_lte?: String;
  targetColumn_gt?: String;
  targetColumn_gte?: String;
  targetColumn_contains?: String;
  targetColumn_not_contains?: String;
  targetColumn_starts_with?: String;
  targetColumn_not_starts_with?: String;
  targetColumn_ends_with?: String;
  targetColumn_not_ends_with?: String;
  inputColumn?: InputColumnWhereInput;
  AND?: JoinWhereInput[] | JoinWhereInput;
  OR?: JoinWhereInput[] | JoinWhereInput;
  NOT?: JoinWhereInput[] | JoinWhereInput;
}

export type DatabaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export type InputColumnWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type JoinWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ResourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AttributeCreateInput {
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceCreateOneWithoutAttributesInput;
  attributes?: AttributeCreateManyWithoutAttributeInput;
  attribute?: AttributeCreateOneWithoutAttributesInput;
  inputColumns?: InputColumnCreateManyWithoutAttributeInput;
}

export interface ResourceCreateOneWithoutAttributesInput {
  create?: ResourceCreateWithoutAttributesInput;
  connect?: ResourceWhereUniqueInput;
}

export interface ResourceCreateWithoutAttributesInput {
  name: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  database: DatabaseCreateOneWithoutResourcesInput;
}

export interface DatabaseCreateOneWithoutResourcesInput {
  create?: DatabaseCreateWithoutResourcesInput;
  connect?: DatabaseWhereUniqueInput;
}

export interface DatabaseCreateWithoutResourcesInput {
  name: String;
}

export interface AttributeCreateManyWithoutAttributeInput {
  create?:
    | AttributeCreateWithoutAttributeInput[]
    | AttributeCreateWithoutAttributeInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
}

export interface AttributeCreateWithoutAttributeInput {
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceCreateOneWithoutAttributesInput;
  attributes?: AttributeCreateManyWithoutAttributeInput;
  inputColumns?: InputColumnCreateManyWithoutAttributeInput;
}

export interface InputColumnCreateManyWithoutAttributeInput {
  create?:
    | InputColumnCreateWithoutAttributeInput[]
    | InputColumnCreateWithoutAttributeInput;
  connect?: InputColumnWhereUniqueInput[] | InputColumnWhereUniqueInput;
}

export interface InputColumnCreateWithoutAttributeInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  joins?: JoinCreateManyWithoutInputColumnInput;
}

export interface JoinCreateManyWithoutInputColumnInput {
  create?:
    | JoinCreateWithoutInputColumnInput[]
    | JoinCreateWithoutInputColumnInput;
  connect?: JoinWhereUniqueInput[] | JoinWhereUniqueInput;
}

export interface JoinCreateWithoutInputColumnInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface AttributeCreateOneWithoutAttributesInput {
  create?: AttributeCreateWithoutAttributesInput;
  connect?: AttributeWhereUniqueInput;
}

export interface AttributeCreateWithoutAttributesInput {
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceCreateOneWithoutAttributesInput;
  attribute?: AttributeCreateOneWithoutAttributesInput;
  inputColumns?: InputColumnCreateManyWithoutAttributeInput;
}

export interface AttributeUpdateInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceUpdateOneWithoutAttributesInput;
  attributes?: AttributeUpdateManyWithoutAttributeInput;
  attribute?: AttributeUpdateOneWithoutAttributesInput;
  inputColumns?: InputColumnUpdateManyWithoutAttributeInput;
}

export interface ResourceUpdateOneWithoutAttributesInput {
  create?: ResourceCreateWithoutAttributesInput;
  update?: ResourceUpdateWithoutAttributesDataInput;
  upsert?: ResourceUpsertWithoutAttributesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ResourceWhereUniqueInput;
}

export interface ResourceUpdateWithoutAttributesDataInput {
  name?: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  database?: DatabaseUpdateOneRequiredWithoutResourcesInput;
}

export interface DatabaseUpdateOneRequiredWithoutResourcesInput {
  create?: DatabaseCreateWithoutResourcesInput;
  update?: DatabaseUpdateWithoutResourcesDataInput;
  upsert?: DatabaseUpsertWithoutResourcesInput;
  connect?: DatabaseWhereUniqueInput;
}

export interface DatabaseUpdateWithoutResourcesDataInput {
  name?: String;
}

export interface DatabaseUpsertWithoutResourcesInput {
  update: DatabaseUpdateWithoutResourcesDataInput;
  create: DatabaseCreateWithoutResourcesInput;
}

export interface ResourceUpsertWithoutAttributesInput {
  update: ResourceUpdateWithoutAttributesDataInput;
  create: ResourceCreateWithoutAttributesInput;
}

export interface AttributeUpdateManyWithoutAttributeInput {
  create?:
    | AttributeCreateWithoutAttributeInput[]
    | AttributeCreateWithoutAttributeInput;
  delete?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  set?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  disconnect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  update?:
    | AttributeUpdateWithWhereUniqueWithoutAttributeInput[]
    | AttributeUpdateWithWhereUniqueWithoutAttributeInput;
  upsert?:
    | AttributeUpsertWithWhereUniqueWithoutAttributeInput[]
    | AttributeUpsertWithWhereUniqueWithoutAttributeInput;
  deleteMany?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  updateMany?:
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput;
}

export interface AttributeUpdateWithWhereUniqueWithoutAttributeInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutAttributeDataInput;
}

export interface AttributeUpdateWithoutAttributeDataInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceUpdateOneWithoutAttributesInput;
  attributes?: AttributeUpdateManyWithoutAttributeInput;
  inputColumns?: InputColumnUpdateManyWithoutAttributeInput;
}

export interface InputColumnUpdateManyWithoutAttributeInput {
  create?:
    | InputColumnCreateWithoutAttributeInput[]
    | InputColumnCreateWithoutAttributeInput;
  delete?: InputColumnWhereUniqueInput[] | InputColumnWhereUniqueInput;
  connect?: InputColumnWhereUniqueInput[] | InputColumnWhereUniqueInput;
  set?: InputColumnWhereUniqueInput[] | InputColumnWhereUniqueInput;
  disconnect?: InputColumnWhereUniqueInput[] | InputColumnWhereUniqueInput;
  update?:
    | InputColumnUpdateWithWhereUniqueWithoutAttributeInput[]
    | InputColumnUpdateWithWhereUniqueWithoutAttributeInput;
  upsert?:
    | InputColumnUpsertWithWhereUniqueWithoutAttributeInput[]
    | InputColumnUpsertWithWhereUniqueWithoutAttributeInput;
  deleteMany?: InputColumnScalarWhereInput[] | InputColumnScalarWhereInput;
  updateMany?:
    | InputColumnUpdateManyWithWhereNestedInput[]
    | InputColumnUpdateManyWithWhereNestedInput;
}

export interface InputColumnUpdateWithWhereUniqueWithoutAttributeInput {
  where: InputColumnWhereUniqueInput;
  data: InputColumnUpdateWithoutAttributeDataInput;
}

export interface InputColumnUpdateWithoutAttributeDataInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  joins?: JoinUpdateManyWithoutInputColumnInput;
}

export interface JoinUpdateManyWithoutInputColumnInput {
  create?:
    | JoinCreateWithoutInputColumnInput[]
    | JoinCreateWithoutInputColumnInput;
  delete?: JoinWhereUniqueInput[] | JoinWhereUniqueInput;
  connect?: JoinWhereUniqueInput[] | JoinWhereUniqueInput;
  set?: JoinWhereUniqueInput[] | JoinWhereUniqueInput;
  disconnect?: JoinWhereUniqueInput[] | JoinWhereUniqueInput;
  update?:
    | JoinUpdateWithWhereUniqueWithoutInputColumnInput[]
    | JoinUpdateWithWhereUniqueWithoutInputColumnInput;
  upsert?:
    | JoinUpsertWithWhereUniqueWithoutInputColumnInput[]
    | JoinUpsertWithWhereUniqueWithoutInputColumnInput;
  deleteMany?: JoinScalarWhereInput[] | JoinScalarWhereInput;
  updateMany?:
    | JoinUpdateManyWithWhereNestedInput[]
    | JoinUpdateManyWithWhereNestedInput;
}

export interface JoinUpdateWithWhereUniqueWithoutInputColumnInput {
  where: JoinWhereUniqueInput;
  data: JoinUpdateWithoutInputColumnDataInput;
}

export interface JoinUpdateWithoutInputColumnDataInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface JoinUpsertWithWhereUniqueWithoutInputColumnInput {
  where: JoinWhereUniqueInput;
  update: JoinUpdateWithoutInputColumnDataInput;
  create: JoinCreateWithoutInputColumnInput;
}

export interface JoinScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  sourceOwner?: String;
  sourceOwner_not?: String;
  sourceOwner_in?: String[] | String;
  sourceOwner_not_in?: String[] | String;
  sourceOwner_lt?: String;
  sourceOwner_lte?: String;
  sourceOwner_gt?: String;
  sourceOwner_gte?: String;
  sourceOwner_contains?: String;
  sourceOwner_not_contains?: String;
  sourceOwner_starts_with?: String;
  sourceOwner_not_starts_with?: String;
  sourceOwner_ends_with?: String;
  sourceOwner_not_ends_with?: String;
  sourceTable?: String;
  sourceTable_not?: String;
  sourceTable_in?: String[] | String;
  sourceTable_not_in?: String[] | String;
  sourceTable_lt?: String;
  sourceTable_lte?: String;
  sourceTable_gt?: String;
  sourceTable_gte?: String;
  sourceTable_contains?: String;
  sourceTable_not_contains?: String;
  sourceTable_starts_with?: String;
  sourceTable_not_starts_with?: String;
  sourceTable_ends_with?: String;
  sourceTable_not_ends_with?: String;
  sourceColumn?: String;
  sourceColumn_not?: String;
  sourceColumn_in?: String[] | String;
  sourceColumn_not_in?: String[] | String;
  sourceColumn_lt?: String;
  sourceColumn_lte?: String;
  sourceColumn_gt?: String;
  sourceColumn_gte?: String;
  sourceColumn_contains?: String;
  sourceColumn_not_contains?: String;
  sourceColumn_starts_with?: String;
  sourceColumn_not_starts_with?: String;
  sourceColumn_ends_with?: String;
  sourceColumn_not_ends_with?: String;
  targetOwner?: String;
  targetOwner_not?: String;
  targetOwner_in?: String[] | String;
  targetOwner_not_in?: String[] | String;
  targetOwner_lt?: String;
  targetOwner_lte?: String;
  targetOwner_gt?: String;
  targetOwner_gte?: String;
  targetOwner_contains?: String;
  targetOwner_not_contains?: String;
  targetOwner_starts_with?: String;
  targetOwner_not_starts_with?: String;
  targetOwner_ends_with?: String;
  targetOwner_not_ends_with?: String;
  targetTable?: String;
  targetTable_not?: String;
  targetTable_in?: String[] | String;
  targetTable_not_in?: String[] | String;
  targetTable_lt?: String;
  targetTable_lte?: String;
  targetTable_gt?: String;
  targetTable_gte?: String;
  targetTable_contains?: String;
  targetTable_not_contains?: String;
  targetTable_starts_with?: String;
  targetTable_not_starts_with?: String;
  targetTable_ends_with?: String;
  targetTable_not_ends_with?: String;
  targetColumn?: String;
  targetColumn_not?: String;
  targetColumn_in?: String[] | String;
  targetColumn_not_in?: String[] | String;
  targetColumn_lt?: String;
  targetColumn_lte?: String;
  targetColumn_gt?: String;
  targetColumn_gte?: String;
  targetColumn_contains?: String;
  targetColumn_not_contains?: String;
  targetColumn_starts_with?: String;
  targetColumn_not_starts_with?: String;
  targetColumn_ends_with?: String;
  targetColumn_not_ends_with?: String;
  AND?: JoinScalarWhereInput[] | JoinScalarWhereInput;
  OR?: JoinScalarWhereInput[] | JoinScalarWhereInput;
  NOT?: JoinScalarWhereInput[] | JoinScalarWhereInput;
}

export interface JoinUpdateManyWithWhereNestedInput {
  where: JoinScalarWhereInput;
  data: JoinUpdateManyDataInput;
}

export interface JoinUpdateManyDataInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface InputColumnUpsertWithWhereUniqueWithoutAttributeInput {
  where: InputColumnWhereUniqueInput;
  update: InputColumnUpdateWithoutAttributeDataInput;
  create: InputColumnCreateWithoutAttributeInput;
}

export interface InputColumnScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: String;
  owner_not?: String;
  owner_in?: String[] | String;
  owner_not_in?: String[] | String;
  owner_lt?: String;
  owner_lte?: String;
  owner_gt?: String;
  owner_gte?: String;
  owner_contains?: String;
  owner_not_contains?: String;
  owner_starts_with?: String;
  owner_not_starts_with?: String;
  owner_ends_with?: String;
  owner_not_ends_with?: String;
  table?: String;
  table_not?: String;
  table_in?: String[] | String;
  table_not_in?: String[] | String;
  table_lt?: String;
  table_lte?: String;
  table_gt?: String;
  table_gte?: String;
  table_contains?: String;
  table_not_contains?: String;
  table_starts_with?: String;
  table_not_starts_with?: String;
  table_ends_with?: String;
  table_not_ends_with?: String;
  column?: String;
  column_not?: String;
  column_in?: String[] | String;
  column_not_in?: String[] | String;
  column_lt?: String;
  column_lte?: String;
  column_gt?: String;
  column_gte?: String;
  column_contains?: String;
  column_not_contains?: String;
  column_starts_with?: String;
  column_not_starts_with?: String;
  column_ends_with?: String;
  column_not_ends_with?: String;
  script?: String;
  script_not?: String;
  script_in?: String[] | String;
  script_not_in?: String[] | String;
  script_lt?: String;
  script_lte?: String;
  script_gt?: String;
  script_gte?: String;
  script_contains?: String;
  script_not_contains?: String;
  script_starts_with?: String;
  script_not_starts_with?: String;
  script_ends_with?: String;
  script_not_ends_with?: String;
  staticValue?: String;
  staticValue_not?: String;
  staticValue_in?: String[] | String;
  staticValue_not_in?: String[] | String;
  staticValue_lt?: String;
  staticValue_lte?: String;
  staticValue_gt?: String;
  staticValue_gte?: String;
  staticValue_contains?: String;
  staticValue_not_contains?: String;
  staticValue_starts_with?: String;
  staticValue_not_starts_with?: String;
  staticValue_ends_with?: String;
  staticValue_not_ends_with?: String;
  AND?: InputColumnScalarWhereInput[] | InputColumnScalarWhereInput;
  OR?: InputColumnScalarWhereInput[] | InputColumnScalarWhereInput;
  NOT?: InputColumnScalarWhereInput[] | InputColumnScalarWhereInput;
}

export interface InputColumnUpdateManyWithWhereNestedInput {
  where: InputColumnScalarWhereInput;
  data: InputColumnUpdateManyDataInput;
}

export interface InputColumnUpdateManyDataInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
}

export interface AttributeUpsertWithWhereUniqueWithoutAttributeInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutAttributeDataInput;
  create: AttributeCreateWithoutAttributeInput;
}

export interface AttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  mergingScript?: String;
  mergingScript_not?: String;
  mergingScript_in?: String[] | String;
  mergingScript_not_in?: String[] | String;
  mergingScript_lt?: String;
  mergingScript_lte?: String;
  mergingScript_gt?: String;
  mergingScript_gte?: String;
  mergingScript_contains?: String;
  mergingScript_not_contains?: String;
  mergingScript_starts_with?: String;
  mergingScript_not_starts_with?: String;
  mergingScript_ends_with?: String;
  mergingScript_not_ends_with?: String;
  isProfile?: Boolean;
  isProfile_not?: Boolean;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  comment?: String;
  comment_not?: String;
  comment_in?: String[] | String;
  comment_not_in?: String[] | String;
  comment_lt?: String;
  comment_lte?: String;
  comment_gt?: String;
  comment_gte?: String;
  comment_contains?: String;
  comment_not_contains?: String;
  comment_starts_with?: String;
  comment_not_starts_with?: String;
  comment_ends_with?: String;
  comment_not_ends_with?: String;
  depth?: Int;
  depth_not?: Int;
  depth_in?: Int[] | Int;
  depth_not_in?: Int[] | Int;
  depth_lt?: Int;
  depth_lte?: Int;
  depth_gt?: Int;
  depth_gte?: Int;
  AND?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  OR?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  NOT?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
}

export interface AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput;
  data: AttributeUpdateManyDataInput;
}

export interface AttributeUpdateManyDataInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
}

export interface AttributeUpdateOneWithoutAttributesInput {
  create?: AttributeCreateWithoutAttributesInput;
  update?: AttributeUpdateWithoutAttributesDataInput;
  upsert?: AttributeUpsertWithoutAttributesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AttributeWhereUniqueInput;
}

export interface AttributeUpdateWithoutAttributesDataInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceUpdateOneWithoutAttributesInput;
  attribute?: AttributeUpdateOneWithoutAttributesInput;
  inputColumns?: InputColumnUpdateManyWithoutAttributeInput;
}

export interface AttributeUpsertWithoutAttributesInput {
  update: AttributeUpdateWithoutAttributesDataInput;
  create: AttributeCreateWithoutAttributesInput;
}

export interface AttributeUpdateManyMutationInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
}

export interface DatabaseCreateInput {
  name: String;
  resources?: ResourceCreateManyWithoutDatabaseInput;
}

export interface ResourceCreateManyWithoutDatabaseInput {
  create?:
    | ResourceCreateWithoutDatabaseInput[]
    | ResourceCreateWithoutDatabaseInput;
  connect?: ResourceWhereUniqueInput[] | ResourceWhereUniqueInput;
}

export interface ResourceCreateWithoutDatabaseInput {
  name: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  attributes?: AttributeCreateManyWithoutResourceInput;
}

export interface AttributeCreateManyWithoutResourceInput {
  create?:
    | AttributeCreateWithoutResourceInput[]
    | AttributeCreateWithoutResourceInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
}

export interface AttributeCreateWithoutResourceInput {
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  attributes?: AttributeCreateManyWithoutAttributeInput;
  attribute?: AttributeCreateOneWithoutAttributesInput;
  inputColumns?: InputColumnCreateManyWithoutAttributeInput;
}

export interface DatabaseUpdateInput {
  name?: String;
  resources?: ResourceUpdateManyWithoutDatabaseInput;
}

export interface ResourceUpdateManyWithoutDatabaseInput {
  create?:
    | ResourceCreateWithoutDatabaseInput[]
    | ResourceCreateWithoutDatabaseInput;
  delete?: ResourceWhereUniqueInput[] | ResourceWhereUniqueInput;
  connect?: ResourceWhereUniqueInput[] | ResourceWhereUniqueInput;
  set?: ResourceWhereUniqueInput[] | ResourceWhereUniqueInput;
  disconnect?: ResourceWhereUniqueInput[] | ResourceWhereUniqueInput;
  update?:
    | ResourceUpdateWithWhereUniqueWithoutDatabaseInput[]
    | ResourceUpdateWithWhereUniqueWithoutDatabaseInput;
  upsert?:
    | ResourceUpsertWithWhereUniqueWithoutDatabaseInput[]
    | ResourceUpsertWithWhereUniqueWithoutDatabaseInput;
  deleteMany?: ResourceScalarWhereInput[] | ResourceScalarWhereInput;
  updateMany?:
    | ResourceUpdateManyWithWhereNestedInput[]
    | ResourceUpdateManyWithWhereNestedInput;
}

export interface ResourceUpdateWithWhereUniqueWithoutDatabaseInput {
  where: ResourceWhereUniqueInput;
  data: ResourceUpdateWithoutDatabaseDataInput;
}

export interface ResourceUpdateWithoutDatabaseDataInput {
  name?: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  attributes?: AttributeUpdateManyWithoutResourceInput;
}

export interface AttributeUpdateManyWithoutResourceInput {
  create?:
    | AttributeCreateWithoutResourceInput[]
    | AttributeCreateWithoutResourceInput;
  delete?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  set?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  disconnect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  update?:
    | AttributeUpdateWithWhereUniqueWithoutResourceInput[]
    | AttributeUpdateWithWhereUniqueWithoutResourceInput;
  upsert?:
    | AttributeUpsertWithWhereUniqueWithoutResourceInput[]
    | AttributeUpsertWithWhereUniqueWithoutResourceInput;
  deleteMany?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  updateMany?:
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput;
}

export interface AttributeUpdateWithWhereUniqueWithoutResourceInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutResourceDataInput;
}

export interface AttributeUpdateWithoutResourceDataInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  attributes?: AttributeUpdateManyWithoutAttributeInput;
  attribute?: AttributeUpdateOneWithoutAttributesInput;
  inputColumns?: InputColumnUpdateManyWithoutAttributeInput;
}

export interface AttributeUpsertWithWhereUniqueWithoutResourceInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutResourceDataInput;
  create: AttributeCreateWithoutResourceInput;
}

export interface ResourceUpsertWithWhereUniqueWithoutDatabaseInput {
  where: ResourceWhereUniqueInput;
  update: ResourceUpdateWithoutDatabaseDataInput;
  create: ResourceCreateWithoutDatabaseInput;
}

export interface ResourceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  primaryKeyOwner?: String;
  primaryKeyOwner_not?: String;
  primaryKeyOwner_in?: String[] | String;
  primaryKeyOwner_not_in?: String[] | String;
  primaryKeyOwner_lt?: String;
  primaryKeyOwner_lte?: String;
  primaryKeyOwner_gt?: String;
  primaryKeyOwner_gte?: String;
  primaryKeyOwner_contains?: String;
  primaryKeyOwner_not_contains?: String;
  primaryKeyOwner_starts_with?: String;
  primaryKeyOwner_not_starts_with?: String;
  primaryKeyOwner_ends_with?: String;
  primaryKeyOwner_not_ends_with?: String;
  primaryKeyTable?: String;
  primaryKeyTable_not?: String;
  primaryKeyTable_in?: String[] | String;
  primaryKeyTable_not_in?: String[] | String;
  primaryKeyTable_lt?: String;
  primaryKeyTable_lte?: String;
  primaryKeyTable_gt?: String;
  primaryKeyTable_gte?: String;
  primaryKeyTable_contains?: String;
  primaryKeyTable_not_contains?: String;
  primaryKeyTable_starts_with?: String;
  primaryKeyTable_not_starts_with?: String;
  primaryKeyTable_ends_with?: String;
  primaryKeyTable_not_ends_with?: String;
  primaryKeyColumn?: String;
  primaryKeyColumn_not?: String;
  primaryKeyColumn_in?: String[] | String;
  primaryKeyColumn_not_in?: String[] | String;
  primaryKeyColumn_lt?: String;
  primaryKeyColumn_lte?: String;
  primaryKeyColumn_gt?: String;
  primaryKeyColumn_gte?: String;
  primaryKeyColumn_contains?: String;
  primaryKeyColumn_not_contains?: String;
  primaryKeyColumn_starts_with?: String;
  primaryKeyColumn_not_starts_with?: String;
  primaryKeyColumn_ends_with?: String;
  primaryKeyColumn_not_ends_with?: String;
  AND?: ResourceScalarWhereInput[] | ResourceScalarWhereInput;
  OR?: ResourceScalarWhereInput[] | ResourceScalarWhereInput;
  NOT?: ResourceScalarWhereInput[] | ResourceScalarWhereInput;
}

export interface ResourceUpdateManyWithWhereNestedInput {
  where: ResourceScalarWhereInput;
  data: ResourceUpdateManyDataInput;
}

export interface ResourceUpdateManyDataInput {
  name?: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
}

export interface DatabaseUpdateManyMutationInput {
  name?: String;
}

export interface InputColumnCreateInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  joins?: JoinCreateManyWithoutInputColumnInput;
  attribute: AttributeCreateOneWithoutInputColumnsInput;
}

export interface AttributeCreateOneWithoutInputColumnsInput {
  create?: AttributeCreateWithoutInputColumnsInput;
  connect?: AttributeWhereUniqueInput;
}

export interface AttributeCreateWithoutInputColumnsInput {
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceCreateOneWithoutAttributesInput;
  attributes?: AttributeCreateManyWithoutAttributeInput;
  attribute?: AttributeCreateOneWithoutAttributesInput;
}

export interface InputColumnUpdateInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  joins?: JoinUpdateManyWithoutInputColumnInput;
  attribute?: AttributeUpdateOneRequiredWithoutInputColumnsInput;
}

export interface AttributeUpdateOneRequiredWithoutInputColumnsInput {
  create?: AttributeCreateWithoutInputColumnsInput;
  update?: AttributeUpdateWithoutInputColumnsDataInput;
  upsert?: AttributeUpsertWithoutInputColumnsInput;
  connect?: AttributeWhereUniqueInput;
}

export interface AttributeUpdateWithoutInputColumnsDataInput {
  name?: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
  resource?: ResourceUpdateOneWithoutAttributesInput;
  attributes?: AttributeUpdateManyWithoutAttributeInput;
  attribute?: AttributeUpdateOneWithoutAttributesInput;
}

export interface AttributeUpsertWithoutInputColumnsInput {
  update: AttributeUpdateWithoutInputColumnsDataInput;
  create: AttributeCreateWithoutInputColumnsInput;
}

export interface InputColumnUpdateManyMutationInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
}

export interface JoinCreateInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
  inputColumn: InputColumnCreateOneWithoutJoinsInput;
}

export interface InputColumnCreateOneWithoutJoinsInput {
  create?: InputColumnCreateWithoutJoinsInput;
  connect?: InputColumnWhereUniqueInput;
}

export interface InputColumnCreateWithoutJoinsInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  attribute: AttributeCreateOneWithoutInputColumnsInput;
}

export interface JoinUpdateInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
  inputColumn?: InputColumnUpdateOneRequiredWithoutJoinsInput;
}

export interface InputColumnUpdateOneRequiredWithoutJoinsInput {
  create?: InputColumnCreateWithoutJoinsInput;
  update?: InputColumnUpdateWithoutJoinsDataInput;
  upsert?: InputColumnUpsertWithoutJoinsInput;
  connect?: InputColumnWhereUniqueInput;
}

export interface InputColumnUpdateWithoutJoinsDataInput {
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
  attribute?: AttributeUpdateOneRequiredWithoutInputColumnsInput;
}

export interface InputColumnUpsertWithoutJoinsInput {
  update: InputColumnUpdateWithoutJoinsDataInput;
  create: InputColumnCreateWithoutJoinsInput;
}

export interface JoinUpdateManyMutationInput {
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface ResourceCreateInput {
  name: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  attributes?: AttributeCreateManyWithoutResourceInput;
  database: DatabaseCreateOneWithoutResourcesInput;
}

export interface ResourceUpdateInput {
  name?: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
  attributes?: AttributeUpdateManyWithoutResourceInput;
  database?: DatabaseUpdateOneRequiredWithoutResourcesInput;
}

export interface ResourceUpdateManyMutationInput {
  name?: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
}

export interface UserCreateInput {
  email: String;
  name: String;
  password: String;
  role?: Role;
}

export interface UserUpdateInput {
  email?: String;
  name?: String;
  password?: String;
  role?: Role;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  name?: String;
  password?: String;
  role?: Role;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttributeWhereInput;
  AND?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  OR?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  NOT?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
}

export interface DatabaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DatabaseWhereInput;
  AND?: DatabaseSubscriptionWhereInput[] | DatabaseSubscriptionWhereInput;
  OR?: DatabaseSubscriptionWhereInput[] | DatabaseSubscriptionWhereInput;
  NOT?: DatabaseSubscriptionWhereInput[] | DatabaseSubscriptionWhereInput;
}

export interface InputColumnSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InputColumnWhereInput;
  AND?: InputColumnSubscriptionWhereInput[] | InputColumnSubscriptionWhereInput;
  OR?: InputColumnSubscriptionWhereInput[] | InputColumnSubscriptionWhereInput;
  NOT?: InputColumnSubscriptionWhereInput[] | InputColumnSubscriptionWhereInput;
}

export interface JoinSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JoinWhereInput;
  AND?: JoinSubscriptionWhereInput[] | JoinSubscriptionWhereInput;
  OR?: JoinSubscriptionWhereInput[] | JoinSubscriptionWhereInput;
  NOT?: JoinSubscriptionWhereInput[] | JoinSubscriptionWhereInput;
}

export interface ResourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResourceWhereInput;
  AND?: ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput;
  OR?: ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput;
  NOT?: ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Attribute {
  id: ID_Output;
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  mergingScript: () => Promise<String>;
  isProfile: () => Promise<Boolean>;
  type: () => Promise<String>;
  comment: () => Promise<String>;
  depth: () => Promise<Int>;
  resource: <T = ResourcePromise>() => T;
  attributes: <T = FragmentableArray<Attribute>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attribute: <T = AttributePromise>() => T;
  inputColumns: <T = FragmentableArray<InputColumn>>(
    args?: {
      where?: InputColumnWhereInput;
      orderBy?: InputColumnOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  mergingScript: () => Promise<AsyncIterator<String>>;
  isProfile: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<String>>;
  comment: () => Promise<AsyncIterator<String>>;
  depth: () => Promise<AsyncIterator<Int>>;
  resource: <T = ResourceSubscription>() => T;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attribute: <T = AttributeSubscription>() => T;
  inputColumns: <T = Promise<AsyncIterator<InputColumnSubscription>>>(
    args?: {
      where?: InputColumnWhereInput;
      orderBy?: InputColumnOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Resource {
  id: ID_Output;
  name: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
}

export interface ResourcePromise extends Promise<Resource>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  primaryKeyOwner: () => Promise<String>;
  primaryKeyTable: () => Promise<String>;
  primaryKeyColumn: () => Promise<String>;
  attributes: <T = FragmentableArray<Attribute>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  database: <T = DatabasePromise>() => T;
}

export interface ResourceSubscription
  extends Promise<AsyncIterator<Resource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  primaryKeyOwner: () => Promise<AsyncIterator<String>>;
  primaryKeyTable: () => Promise<AsyncIterator<String>>;
  primaryKeyColumn: () => Promise<AsyncIterator<String>>;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  database: <T = DatabaseSubscription>() => T;
}

export interface Database {
  id: ID_Output;
  name: String;
}

export interface DatabasePromise extends Promise<Database>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  resources: <T = FragmentableArray<Resource>>(
    args?: {
      where?: ResourceWhereInput;
      orderBy?: ResourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DatabaseSubscription
  extends Promise<AsyncIterator<Database>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  resources: <T = Promise<AsyncIterator<ResourceSubscription>>>(
    args?: {
      where?: ResourceWhereInput;
      orderBy?: ResourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface InputColumn {
  id: ID_Output;
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
}

export interface InputColumnPromise extends Promise<InputColumn>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<String>;
  table: () => Promise<String>;
  column: () => Promise<String>;
  script: () => Promise<String>;
  staticValue: () => Promise<String>;
  joins: <T = FragmentableArray<Join>>(
    args?: {
      where?: JoinWhereInput;
      orderBy?: JoinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attribute: <T = AttributePromise>() => T;
}

export interface InputColumnSubscription
  extends Promise<AsyncIterator<InputColumn>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<String>>;
  table: () => Promise<AsyncIterator<String>>;
  column: () => Promise<AsyncIterator<String>>;
  script: () => Promise<AsyncIterator<String>>;
  staticValue: () => Promise<AsyncIterator<String>>;
  joins: <T = Promise<AsyncIterator<JoinSubscription>>>(
    args?: {
      where?: JoinWhereInput;
      orderBy?: JoinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attribute: <T = AttributeSubscription>() => T;
}

export interface Join {
  id: ID_Output;
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface JoinPromise extends Promise<Join>, Fragmentable {
  id: () => Promise<ID_Output>;
  sourceOwner: () => Promise<String>;
  sourceTable: () => Promise<String>;
  sourceColumn: () => Promise<String>;
  targetOwner: () => Promise<String>;
  targetTable: () => Promise<String>;
  targetColumn: () => Promise<String>;
  inputColumn: <T = InputColumnPromise>() => T;
}

export interface JoinSubscription
  extends Promise<AsyncIterator<Join>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceOwner: () => Promise<AsyncIterator<String>>;
  sourceTable: () => Promise<AsyncIterator<String>>;
  sourceColumn: () => Promise<AsyncIterator<String>>;
  targetOwner: () => Promise<AsyncIterator<String>>;
  targetTable: () => Promise<AsyncIterator<String>>;
  targetColumn: () => Promise<AsyncIterator<String>>;
  inputColumn: <T = InputColumnSubscription>() => T;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DatabaseConnection {
  pageInfo: PageInfo;
  edges: DatabaseEdge[];
}

export interface DatabaseConnectionPromise
  extends Promise<DatabaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DatabaseEdge>>() => T;
  aggregate: <T = AggregateDatabasePromise>() => T;
}

export interface DatabaseConnectionSubscription
  extends Promise<AsyncIterator<DatabaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DatabaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDatabaseSubscription>() => T;
}

export interface DatabaseEdge {
  node: Database;
  cursor: String;
}

export interface DatabaseEdgePromise
  extends Promise<DatabaseEdge>,
    Fragmentable {
  node: <T = DatabasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DatabaseEdgeSubscription
  extends Promise<AsyncIterator<DatabaseEdge>>,
    Fragmentable {
  node: <T = DatabaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDatabase {
  count: Int;
}

export interface AggregateDatabasePromise
  extends Promise<AggregateDatabase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDatabaseSubscription
  extends Promise<AsyncIterator<AggregateDatabase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InputColumnConnection {
  pageInfo: PageInfo;
  edges: InputColumnEdge[];
}

export interface InputColumnConnectionPromise
  extends Promise<InputColumnConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InputColumnEdge>>() => T;
  aggregate: <T = AggregateInputColumnPromise>() => T;
}

export interface InputColumnConnectionSubscription
  extends Promise<AsyncIterator<InputColumnConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InputColumnEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInputColumnSubscription>() => T;
}

export interface InputColumnEdge {
  node: InputColumn;
  cursor: String;
}

export interface InputColumnEdgePromise
  extends Promise<InputColumnEdge>,
    Fragmentable {
  node: <T = InputColumnPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InputColumnEdgeSubscription
  extends Promise<AsyncIterator<InputColumnEdge>>,
    Fragmentable {
  node: <T = InputColumnSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInputColumn {
  count: Int;
}

export interface AggregateInputColumnPromise
  extends Promise<AggregateInputColumn>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInputColumnSubscription
  extends Promise<AsyncIterator<AggregateInputColumn>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JoinConnection {
  pageInfo: PageInfo;
  edges: JoinEdge[];
}

export interface JoinConnectionPromise
  extends Promise<JoinConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JoinEdge>>() => T;
  aggregate: <T = AggregateJoinPromise>() => T;
}

export interface JoinConnectionSubscription
  extends Promise<AsyncIterator<JoinConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JoinEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJoinSubscription>() => T;
}

export interface JoinEdge {
  node: Join;
  cursor: String;
}

export interface JoinEdgePromise extends Promise<JoinEdge>, Fragmentable {
  node: <T = JoinPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JoinEdgeSubscription
  extends Promise<AsyncIterator<JoinEdge>>,
    Fragmentable {
  node: <T = JoinSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJoin {
  count: Int;
}

export interface AggregateJoinPromise
  extends Promise<AggregateJoin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJoinSubscription
  extends Promise<AsyncIterator<AggregateJoin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResourceConnection {
  pageInfo: PageInfo;
  edges: ResourceEdge[];
}

export interface ResourceConnectionPromise
  extends Promise<ResourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResourceEdge>>() => T;
  aggregate: <T = AggregateResourcePromise>() => T;
}

export interface ResourceConnectionSubscription
  extends Promise<AsyncIterator<ResourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResourceSubscription>() => T;
}

export interface ResourceEdge {
  node: Resource;
  cursor: String;
}

export interface ResourceEdgePromise
  extends Promise<ResourceEdge>,
    Fragmentable {
  node: <T = ResourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResourceEdgeSubscription
  extends Promise<AsyncIterator<ResourceEdge>>,
    Fragmentable {
  node: <T = ResourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResource {
  count: Int;
}

export interface AggregateResourcePromise
  extends Promise<AggregateResource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResourceSubscription
  extends Promise<AsyncIterator<AggregateResource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
  role?: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface AttributePreviousValues {
  id: ID_Output;
  name: String;
  mergingScript?: String;
  isProfile?: Boolean;
  type?: String;
  comment?: String;
  depth?: Int;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  mergingScript: () => Promise<String>;
  isProfile: () => Promise<Boolean>;
  type: () => Promise<String>;
  comment: () => Promise<String>;
  depth: () => Promise<Int>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  mergingScript: () => Promise<AsyncIterator<String>>;
  isProfile: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<String>>;
  comment: () => Promise<AsyncIterator<String>>;
  depth: () => Promise<AsyncIterator<Int>>;
}

export interface DatabaseSubscriptionPayload {
  mutation: MutationType;
  node: Database;
  updatedFields: String[];
  previousValues: DatabasePreviousValues;
}

export interface DatabaseSubscriptionPayloadPromise
  extends Promise<DatabaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DatabasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DatabasePreviousValuesPromise>() => T;
}

export interface DatabaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DatabaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DatabaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DatabasePreviousValuesSubscription>() => T;
}

export interface DatabasePreviousValues {
  id: ID_Output;
  name: String;
}

export interface DatabasePreviousValuesPromise
  extends Promise<DatabasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DatabasePreviousValuesSubscription
  extends Promise<AsyncIterator<DatabasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface InputColumnSubscriptionPayload {
  mutation: MutationType;
  node: InputColumn;
  updatedFields: String[];
  previousValues: InputColumnPreviousValues;
}

export interface InputColumnSubscriptionPayloadPromise
  extends Promise<InputColumnSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InputColumnPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InputColumnPreviousValuesPromise>() => T;
}

export interface InputColumnSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InputColumnSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InputColumnSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InputColumnPreviousValuesSubscription>() => T;
}

export interface InputColumnPreviousValues {
  id: ID_Output;
  owner?: String;
  table?: String;
  column?: String;
  script?: String;
  staticValue?: String;
}

export interface InputColumnPreviousValuesPromise
  extends Promise<InputColumnPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<String>;
  table: () => Promise<String>;
  column: () => Promise<String>;
  script: () => Promise<String>;
  staticValue: () => Promise<String>;
}

export interface InputColumnPreviousValuesSubscription
  extends Promise<AsyncIterator<InputColumnPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<String>>;
  table: () => Promise<AsyncIterator<String>>;
  column: () => Promise<AsyncIterator<String>>;
  script: () => Promise<AsyncIterator<String>>;
  staticValue: () => Promise<AsyncIterator<String>>;
}

export interface JoinSubscriptionPayload {
  mutation: MutationType;
  node: Join;
  updatedFields: String[];
  previousValues: JoinPreviousValues;
}

export interface JoinSubscriptionPayloadPromise
  extends Promise<JoinSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JoinPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JoinPreviousValuesPromise>() => T;
}

export interface JoinSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JoinSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JoinSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JoinPreviousValuesSubscription>() => T;
}

export interface JoinPreviousValues {
  id: ID_Output;
  sourceOwner?: String;
  sourceTable?: String;
  sourceColumn?: String;
  targetOwner?: String;
  targetTable?: String;
  targetColumn?: String;
}

export interface JoinPreviousValuesPromise
  extends Promise<JoinPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sourceOwner: () => Promise<String>;
  sourceTable: () => Promise<String>;
  sourceColumn: () => Promise<String>;
  targetOwner: () => Promise<String>;
  targetTable: () => Promise<String>;
  targetColumn: () => Promise<String>;
}

export interface JoinPreviousValuesSubscription
  extends Promise<AsyncIterator<JoinPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceOwner: () => Promise<AsyncIterator<String>>;
  sourceTable: () => Promise<AsyncIterator<String>>;
  sourceColumn: () => Promise<AsyncIterator<String>>;
  targetOwner: () => Promise<AsyncIterator<String>>;
  targetTable: () => Promise<AsyncIterator<String>>;
  targetColumn: () => Promise<AsyncIterator<String>>;
}

export interface ResourceSubscriptionPayload {
  mutation: MutationType;
  node: Resource;
  updatedFields: String[];
  previousValues: ResourcePreviousValues;
}

export interface ResourceSubscriptionPayloadPromise
  extends Promise<ResourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResourcePreviousValuesPromise>() => T;
}

export interface ResourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResourcePreviousValuesSubscription>() => T;
}

export interface ResourcePreviousValues {
  id: ID_Output;
  name: String;
  primaryKeyOwner?: String;
  primaryKeyTable?: String;
  primaryKeyColumn?: String;
}

export interface ResourcePreviousValuesPromise
  extends Promise<ResourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  primaryKeyOwner: () => Promise<String>;
  primaryKeyTable: () => Promise<String>;
  primaryKeyColumn: () => Promise<String>;
}

export interface ResourcePreviousValuesSubscription
  extends Promise<AsyncIterator<ResourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  primaryKeyOwner: () => Promise<AsyncIterator<String>>;
  primaryKeyTable: () => Promise<AsyncIterator<String>>;
  primaryKeyColumn: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
  role?: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Database",
    embedded: false
  },
  {
    name: "Resource",
    embedded: false
  },
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "InputColumn",
    embedded: false
  },
  {
    name: "Join",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://0.0.0.0:4466`
});
export const prisma = new Prisma();
